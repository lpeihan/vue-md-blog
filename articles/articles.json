{
  "hello.md": {
    "title": "Vue-Occupy",
    "tags": "javascript vue tool",
    "date": "2016-08-01",
    "content": "{\r\n  \"title\": \"Vue-Occupy\",\r\n  \"tags\": \"javascript vue tool\",\r\n  \"date\": \"2016-08-01\"\r\n}\r\n\r\nA Vue directive for occupying content places before the data has been loaded.\r\n\r\nIt's good for user experiment improving.\r\n\r\n# Install\r\nUsing `yarn` or `npm` to install `vue-occupy`:\r\n\r\n```\r\n# yarn\r\nyarn add vue-occupy\r\n\r\n# npm\r\nnpm install vue-occupy\r\n```\r\n"
  },
  "promise.md": {
    "title": "promise",
    "tags": "javascript 技术",
    "date": "2016-08-01",
    "content": "{\r\n  \"title\": \"promise\",\r\n  \"tags\": \"javascript 技术\",\r\n  \"date\": \"2016-08-01\"\r\n}\r\n\r\n* 概念\r\n\r\n`Promise`是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大，能优雅解决回调地狱难题。\r\n\r\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。\r\n\r\n`Promise`对象代表一个异步操作，有三种状态：`Pending(进行中)`、`Resolved(已完成)`和`Rejected(已失败)`。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 \r\n\r\n* 基本用法\r\n\r\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。\r\n\r\n`resolve`将`Promise`对象的状态从从`Pending`变为`Resolved`，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。\r\n\r\n`reject`函数的作用是，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\r\n\r\n`Promise`实例生成以后，可以用`then`方法分别制定`Resolved`状态和`Rejected`状态的回调函数。\r\n\r\n```javascript\r\nconst promise = new Promise(function(resolve, reject) {\r\n  // ... some code\r\n  if (/* 异步操作成功 */) {\r\n    resolve(value);\r\n  } else {\r\n    reject(error);\r\n  }\r\n});\r\n\r\npromise.then(function(value) {\r\n  // sucess\r\n}, function(error) {\r\n  // failure\r\n});\r\n```\r\n"
  },
  "test.md": {
    "title": "test",
    "tags": "javascript",
    "content": "{\r\n  \"title\": \"test\",\r\n  \"tags\": \"javascript\"\r\n}\r\n\r\n# hello worldddccd"
  }
}